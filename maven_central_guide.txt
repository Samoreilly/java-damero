MAVEN CENTRAL UPLOAD GUIDE

CAN THIS LIBRARY BE INSTALLED AS A DEPENDENCY?
YES - once uploaded to Maven Central, users can install it just like any other dependency.

HOW TO UPLOAD TO MAVEN CENTRAL:

Prerequisites:
1. Create a Sonatype account at https://issues.sonatype.org
2. Create a JIRA ticket to get your groupId approved (java.damero)
3. Generate GPG keys for signing

Step 1: Update pom.xml with required information

You'll need to add these sections to your pom.xml:

- Project metadata (name, description, URL, licenses, developers, SCM)
- Distribution management (Maven Central URLs)
- Plugin configuration (maven-gpg-plugin for signing)
- Property for GPG key details

Step 2: Sign artifacts

Maven Central requires signed artifacts. You'll need:
- GPG installed on your system
- GPG keys created and published
- Configure signing in pom.xml

Step 3: Deploy to Staging Repository

- Use mvn deploy with staging profile
- Send artifacts to Sonatype Nexus repository
- Sonatype will review and promote to Central

Step 4: Testing with SNAPSHOT version first

- Upload as 0.0.1-SNAPSHOT to test
- Verify it downloads correctly
- Then publish full release (0.0.1) to Maven Central

HOW USERS WOULD INSTALL IT:

Once on Maven Central, users add to their pom.xml:

```xml
<dependency>
    <groupId>java.damero</groupId>
    <artifactId>demo</artifactId>
    <version>0.0.1</version>
</dependency>
```

THINGS TO FIX BEFORE UPLOADING:

1. Change artifactId from "demo" to something descriptive like "kafka-damero"
2. Fix pom.xml metadata (proper name, URL, license, etc.)
3. Add javadoc generation
4. Add sources jar generation
5. Configure GPG signing
6. Configure distribution management

The library structure is ready, but you need to configure Maven Central deployment settings.

ALTERNATIVE: Publish to GitHub Packages First

Simpler approach:
1. Configure GitHub Packages in pom.xml
2. Use GitHub Actions to build and publish
3. Users install from GitHub Packages first
4. Later migrate to Maven Central

GITHUB PACKAGES IS EASIER THAN MAVEN CENTRAL

GitHub Packages workflow:
- No JIRA ticket needed
- No GPG signing required
- Automatic CI/CD with GitHub Actions
- Users can install with GitHub Packages repository URL

//
//package net.damero.RegisterBean;
//
//import jakarta.annotation.PostConstruct;
//import net.damero.Annotations.CustomKafkaListener;
//import net.damero.CustomKafkaSetup.RetryKafkaListener.KafkaRetryListener;
//import net.damero.CustomObject.EventWrapper;
//import org.reflections.Reflections;
//import org.reflections.scanners.Scanners;
//import org.springframework.beans.factory.annotation.Autowired;
//import org.springframework.beans.factory.annotation.Qualifier;
//import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
//import org.springframework.context.ApplicationContext;
//import org.springframework.kafka.annotation.KafkaListener;
//import org.springframework.kafka.config.*;
//import org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter;
//import org.springframework.messaging.handler.annotation.support.DefaultMessageHandlerMethodFactory;
//import org.springframework.stereotype.Component;
//
//import java.lang.reflect.Method;
//import java.util.HashSet;
//import java.util.Set;
//import java.util.concurrent.atomic.AtomicLong;
//
//@Component
//@ConditionalOnProperty(name = "register.retry.enabled", havingValue = "true", matchIfMissing = true)
//public class RegisterRetryBean {
//
//    @Autowired
//    ApplicationContext context;
//
//    @Autowired
//    private KafkaListenerEndpointRegistry registry;
//
//    @Autowired
//    @Qualifier("defaultFactory")
//    private KafkaListenerContainerFactory<?> kafkaListenerContainerFactory;
//
//    @Autowired
//    private KafkaRetryListener kafkaRetryListener; // Inject your retry listener
//
//    String kafkaGroupId = "kafkaGroupId";
//    static AtomicLong endpointIdIndex = new AtomicLong(1);
//
//    @PostConstruct
//    public void listenerSetup() {
//        Reflections reflections = new Reflections("net.damero", Scanners.MethodsAnnotated);
//
//        Set<Method> methods = reflections.getMethodsAnnotatedWith(CustomKafkaListener.class);
//
//        System.out.println("Found " + methods.size() + " methods with @CustomKafkaListener");
//
//        // Collect all unique retry topics
//        Set<String> retryTopics = new HashSet<>();
//
//        for (Method method : methods) {
//            if (!method.isAnnotationPresent(KafkaListener.class)) {
//                throw new IllegalStateException(
//                        "@CustomKafkaListener on " + method.getName() +
//                                " must also have @KafkaListener annotation"
//                );
//            }
//
//            CustomKafkaListener customKafkaListener = method.getAnnotation(CustomKafkaListener.class);
//            KafkaListener kafkaListener = method.getAnnotation(KafkaListener.class);
//
//            // Verify topic consistency
//            if (kafkaListener.topics().length > 0 &&
//                    !customKafkaListener.topic().equals(kafkaListener.topics()[0]) &&
//                    !customKafkaListener.retryableTopic().isEmpty()) {
//                throw new IllegalStateException(
//                        "@CustomKafkaListener topic must match @KafkaListener topic"
//                );
//            }
//
//            // Collect retry topic if retryable
//            if (customKafkaListener.retryable() &&
//                    !customKafkaListener.retryableTopic().isEmpty()) {
//                retryTopics.add(customKafkaListener.retryableTopic());
//            }
//        }
//
//        // Register KafkaRetryListener for each unique retry topic
//        for (String retryTopic : retryTopics) {
//            System.out.println("ðŸ”„ Registering KafkaRetryListener for retry topic: " + retryTopic);
//            registerRetryListener(retryTopic);
//        }
//    }
//
//    /**
//     * Register the KafkaRetryListener to consume from a retry topic
//     */
//    private void registerRetryListener(String retryTopic) {
//        MethodKafkaListenerEndpoint<String, EventWrapper<?>> endpoint =
//                new MethodKafkaListenerEndpoint<>();
//
//        endpoint.setId(generateListenerId());
//        endpoint.setGroupId(kafkaGroupId + "-retry");
//        endpoint.setAutoStartup(true);
//        endpoint.setTopics(retryTopic);
//        endpoint.setMessageHandlerMethodFactory(new DefaultMessageHandlerMethodFactory());
//
//        // Set the KafkaRetryListener instance and its onMessage method
//        endpoint.setBean(kafkaRetryListener);
//        try {
//            Method onMessageMethod = KafkaRetryListener.class.getMethod(
//                    "onMessage",
//                    org.apache.kafka.clients.consumer.ConsumerRecord.class
//            );
//            endpoint.setMethod(onMessageMethod);
//        } catch (NoSuchMethodException e) {
//            throw new RuntimeException("Failed to find onMessage method on KafkaRetryListener", e);
//        }
//
//        // Register the endpoint
//        registry.registerListenerContainer(endpoint, kafkaListenerContainerFactory, true);
//
//        System.out.println("âœ… Successfully registered retry listener for topic: " + retryTopic);
//    }
//
//    private String generateListenerId() {
//        return "retry-listener-" + endpointIdIndex.getAndIncrement();
//    }
//}